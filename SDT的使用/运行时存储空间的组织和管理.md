# 综述
其实这里结合pwn来理解非常的好（所以其实很多时候这些底层的东西本身就是如果我理解了之后我再去搞pwn就会显得很自然而然）

一些概念：
- 过程：过程和函数这样的程序单元
  所以面向过程编程其实也就是这个含义
- 过程的活动：过程的一次执行。（因为过程是静态的定义，而活动就是过程动态的描述，而程序一定会结束，所以过程的一次执行就是一次活动）
- 活动记录：即用来存放这个整个过程情况的连续内存（一般而言就是在栈里）（活动记录就是栈帧）

# 内存管理
首先我们了解下内存结构：

低地址

|区域名称|描述|
|---|---|
|Text（代码段）|程序的机器指令|
|Read-only Data|字符串常量、常量等|
|Data（已初始化数据）|全局/静态变量（已初始化）|
|BSS（未初始化数据）|全局/静态变量（未初始化）|
|Heap（堆）|动态分配的内存（如 malloc/new）|
|Stack（栈）|局部变量，函数调用帧等|
高地址

其实这里我们可以想一想为什么要这么设计：
我们可以设想，如果栈是从低到高的增长，那么就要预留，那么堆区和栈区就是有限制的。但是这里存放的是程序中的临时变量，我们并不可以预想会有多少，相向而行可以最大程度的使用到内存的空间。

而，运行时存储空间的组织和管理其实我们主要学习的是栈内空间的管理。因为这里会设计到状态的转移。
![[Pasted image 20250616232258.png]]

而我们把这个函数称作**过程**。这里的栈帧状态是一个大致的状态，毕竟这里就默认没有寄存器这个东西，并且不一定每种语言都用寄存器存放返回值，所以这里需要一个一般情况。
- 返回值解释：
  c程序中返回值一般是用寄存器，而不是使用栈帧。但是大存储（类和结构体都是使用的栈帧传递。所以这里这样写完全是合理的

这里会有这么几个概念：
- 过程
- 名字
- 存储单元

我们定义之前通常都会声明，那么我们有没有想过为什么要声明
```txt
其实就是为了
知道返回值类型、参数数量和类型等信息，用来做内存分配

而类型的本质是什么呢？其实是这个变量应该占据多大的存储空间以及分配处理方式是什么。
```
## 解释内存布局

这里结合pwn和计基的知识我们也知道，调用一个函数首先是
```c
0000000000001129 <func>:  
   1129:       55                      push   %rbp  
   112a:       48 89 e5                mov    %rsp,%rbp  
   112d:       89 7d ec                mov    %edi,-0x14(%rbp)  
   1130:       89 75 e8                mov    %esi,-0x18(%rbp)  
   1133:       8b 55 ec                mov    -0x14(%rbp),%edx  
   1136:       8b 45 e8                mov    -0x18(%rbp),%eax  
   1139:       01 d0                   add    %edx,%eax  
   113b:       89 45 fc                mov    %eax,-0x4(%rbp)  
   113e:       8b 45 fc                mov    -0x4(%rbp),%eax  
   1141:       5d                      pop    %rbp  
   1142:       c3                      ret  
  
0000000000001143 <main>:  
   1143:       55                      push   %rbp  
   1144:       48 89 e5                mov    %rsp,%rbp  
   1147:       48 83 ec 10             sub    $0x10,%rsp  
   114b:       c7 45 fc 01 00 00 00    movl   $0x1,-0x4(%rbp)  
   1152:       c7 45 f8 02 00 00 00    movl   $0x2,-0x8(%rbp)  
   1159:       8b 55 f8                mov    -0x8(%rbp),%edx  
   115c:       8b 45 fc                mov    -0x4(%rbp),%eax  
   115f:       89 d6                   mov    %edx,%esi  
   1161:       89 c7                   mov    %eax,%edi  
   1163:       e8 c1 ff ff ff          call   1129 <func>  
   1168:       b8 00 00 00 00          mov    $0x0,%eax  
   116d:       c9                      leave  
   116e:       c3                      ret
...
```

这个过程的栈空间是
其实这里是做了优化，因为在x86中会首先用寄存器。

要理解这里的内存分配就要理解下
1. call指令到底在做什么：call其实就是一个压栈（下一条指令，eip），然后跳转到相应的位置
2. leave：其实是一个清空栈帧的快捷方式，等价于：mov esp, ebp ;  pop ebp
   经历这个过程之后
## 局部变量
局部变量所有域的长度在编译的时候都能确定。

变长其实是cpp标准不支持的
![[Pasted image 20250617155940.png]]

## 考点：活动树、控制栈、运行栈

### 活动树
活动树原则：
- 从上到下
- 从左到右
- 在栈里用实线，出栈用虚线

### 控制栈
即简单版的运行栈。我们仅将当前运行时栈内的过程（函数）列出来。
比如：
### 运行栈
运行栈是控制栈的拓展，他将当前栈内具体的运行情况描述了下。所以我们需要在控制栈的基础上将栈内情况补充。控制链这些就不用补充了。通常情况是补充以下几个点：
- 参数
- 返回值：返回值写明数据类型，注明表达式：int(表达式)
- 局部变量
参数和局部变量写表达式就好

一个例子：

## 参数传递
参数传递这里需要理解
- 实参
  
- 形参
  简单来说就是函数定义中使用的参数，只是一个“占位符”。所以其并不占用内存空间。只有在函数被调用的时候才会被赋予实际的值。

### 值调用
值引用的时候我们只要将下面遇到的所有的参数直接替换为这参数就行了。并不影响他以前的值。
### 引用调用
注意影响以前的值就好了
### 换名调用
换名调用说人话就是：这个东西无论我们把他称为什么，起什么另外的名字。我们在使用的时候都是将他替换（展开）成最初定义的模样；

举一个例子：
```
void func(int x, y, z) {
	y = y + 1;
	z = z + x;
}

int main() {
	int a = 2;
	int b = 3;
	func(a+b, a, a);
	cout<<a;
}

问输出a是多少：9
```
为什么是9呢？因为我们是将他看作名字，展开。y展开为a。z展开为a+b；

