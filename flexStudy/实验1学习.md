实验代码分析

核心理解三部分：
```c
%{
#include <stdio.h> 
#define RELOP       1
#define OTHER       2
%}
```

```c
relop       \<|\<=|=|\<\>|\>|\>=
other       ([^<=>])+

%%
{relop}     {return RELOP;}
{other}     {return OTHER;}
.								        {} 
%%
```

```c
int yywrap (){
  return 1;
}

void writeout(int c){
  switch(c){
  	case OTHER: fprintf(yyout, "(OTHER,%d)", yyleng);break;
  	case RELOP: fprintf(yyout, "(RELOP,\"%s\")", yytext);break;

    default:break;
  }
  return;
}


int main (int argc, char ** argv){
	int c,j=0;
	if (argc>=2){
	  if ((yyin = fopen(argv[1], "r")) == NULL){
	    printf("Can't open file %s\n", argv[1]);
	    return 1;
	  }
	  if (argc>=3){
	    yyout=fopen(argv[2], "w");
	  }
	}
	while (c = yylex()){
		writeout(c);
	}
	if(argc>=2){
	  fclose(yyin);
	  if (argc>=3) fclose(yyout);
	}
	return 0;
}
```

---
终点是得到一个词法分析的c程序。这里进行宏定义是为了后续编写代码的时候方便。编码是为区别，一般特殊的单个符号能用ASCII码表示就用ASCII码。类似的分到一起。其他随便。

词法分析器也需要和语法分析器交互，所以需要统一的定义。且双方定义编码数值需要一致。

且这里是单纯的词法分析器的构造。所以并没有用上bision。当后面用上bison的时候就会知道。
1. 首先我们需要和bison通信。所以双方需要一起定义。但是重复的定义很麻烦，违反了DRY规则。所以在后续和bison一起使用的时候通常是使用bison分配的。（因为bison会生成一个.h文件）

---
第二个部分正常先写正规式定义。而后在%%中写正规式和动作就好了%%

---
第三个部分是处理逻辑阶段。首先是接受参数。然后是写了一个出来函数`writeout`实现不同情况的输出。

核心函数讲解
1. yylex()
   > `yylex()` 函数是由 **Flex**（一个词法分析器生成工具）自动生成的核心函数，它的主要功能是扫描输入流并按定义的词法规则（正则表达式）识别出一个个 token。
   >  他返回的是一个int型的数据，这个数据只是一个记号，他对应了我们的宏定义。（因为这个是我们动作里规定好的（如果我们在动作里面直接规定输入输出也就不需要后面的writeout了））
2. fflex里面规定了以下一些东西
	1. yyin 输入流
	2. yyout 输出流，默认是标准输出流
	3. yyleng token长度
	4. yytext token真正的字符
3. yywrap()
   > `yywrap()` 是 Flex 生成的一个特殊函数，它的作用是在扫描输入结束时决定是否继续扫描。Flex 会在处理完一个输入流后调用 `yywrap()`，来判断是否有更多的输入流需要处理。
   > 默认返回1，表示结束了，如果返回0表示继续读取

所以通过这些逻辑就可以实现规定的效果

一些规则：
1. 这些规则是从上到下便利的。所以越靠前就相当于越早匹配。所以越靠前越早执行。（最长匹配会干扰）
2. 最长匹配：正则表达式的规则。

# 实验1的内容
实验1的内容相对简单，只是匹配对应的字符
类似
- `()`
- `+` `-` 等

这些都是简单的情况，只需要写相应的正则表达式匹配相应的字符串就可以了。

遇到的情况和解决方案
注释如何表示并解决？

在实验中遇到注释的正确处理，c的注释有两种
- `/**/`
- `//`

其中第一个我想到和查到两种写法：
- `"/*"([^*]|\*+[^*/])*\*+"/"` 
  （这个有个好玩的情况： 之前写的是`"/*"([^*]|\*[^*/])*\*+"/"`但是匹配布料`/***8***/`很好玩，因为这里的规定就是`*`后面就是要跟一个不是`*`，不是`/`的符号，否则就不能匹配。）这个对实验2的引号实验会有关联和提示[[实验2学习#lab1]]
- `"/*".*|\n"*/"`

好像这两个都是可行的，第一个的逻辑是：
固定开头，结尾，规定中间不可以为`*/`。不可以为`*/`规定为除了`*`之外的所有的字符，如果为为`*`就应该遵从第二个规则。也就是`*`可以是任意多个，但是他的后面不能是`/`。

第二个看似可以，因为他规定开头和结尾之后，中间无论是什么都无所谓，但是这个由于正则表达式最长匹配的规则，遇到下面这个正则表达式也会全都吃掉：
`/*asdf*/asdf*/`
但是这个是没有道理的

同时，这个可以引入状态解决
```c
%x COMMENT

<INITIAL>"/*" { BEGIN COMMENT;}
<COMMENT>"*/" { BEGIN INITIAL;}
<COMMENT>.|\n {;}
```

那么这里就有一个最长匹配原则的问题，最长匹配原则到底是谁最长？
>在当前状态中，Flex 会在所有规则中，选取“能够匹配到的最长字符串”对应的那一条规则，作为本轮的匹配结果。

所以最长的是谁？是匹配的字符串，那么和规则有什么关系？
他代表的含义
如果现在有两个规则：
1. a
2. b
a能匹配3个字符，而b匹配了4个字符，那么我就会选择b规则来匹配

这里有一个重要的点：
匹配是单个规则匹配的最长，而不是多次拼接出来的最长

也就是上面的哪个注释状态规则中，如果遇到的是
`/*asdf*/qewr*/`

一直吃到`*/qwer*/`。接下来如果是`.`规则的话只能吃1个字符，而如果是`*/`规则的话能吃2个字符。所以此时会选择第二个。