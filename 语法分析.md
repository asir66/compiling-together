# 导言
1. 语法分析要做什么：
   将记号流 -> 语法树
   ![](Pasted%20image%2020250313103305.png)
2. 语法分析关键词
	- 分析树
	- 文法
		- 上下文无关文法
			- 四元组
				- 产生式和推导
			- 语言
				- 句子
				- 句型
			- 二义性
				- 消除方法
		- 上下文有关文法（没学）
	- 自上而下分析
		- LL(1)文法
		- 预测表算法和构造
	- 自下而上分析
		- LR文法
		- 预测表使用与构造

>课程提要
>本课程主要讲前端的内容。因为优化太难而代码生成器直接替换就行。

上下文无关文法例子：
```c
int a;
a = b+1;
```
在上下文无关文法看来这个语句是合理的，因为本语句是符合语法规则的。他并不由上下文影响。

语法分析器的位置
![](Pasted%20image%2020250313104330.png)
在综述中我们也提到分析器其实是主体，它调用词法分析器

# 上下文无关文法
![](Pasted%20image%2020250313104901.png)
1. 因为语言是集合

正规式
- 可以：
	- 固定的模式
- 不可以
	- 匹配
	- 嵌套
	- 自嵌套

而上下文无关文法允许自嵌套。从而正规语言是上下文无关语言的子集
## 定义
![](Pasted%20image%2020250313110451.png)
疑问点：
1. 什么是非终结符？为什么是非空的？
## 推导
推导：
将人话就是从产生式得到一个语言实例
在从产生式到实例之间的过程为：

一些概念和记号
- 递归
	- 直接递归
- 位置递归
	- 左递归
	- 右递归
- 递归文法

优先推导位置：
- 最左推导
- 最右推导（规范推导）
	- 规范句型
		- 活前缀 - 规范句型 - 句型
		- 句柄
  为什么嘞？：

逆推导：-> 规约，一个终结符串导非递归符

## 分析树
定义：


例子：
![](Pasted%20image%2020250313120451.png)

为什么说我们常用的是规约。因为为了创建这棵树首先拿到的是一堆token。我们有的是产生式和叶子节点。要得到这棵树就需要从下而上就是规约

语法和语言的二意性
一个语言是可以有多个文法的。

挺逗的，书上说分析树其实是一个概念上的东西，并不一定真正产生



句型：

# 新开始


一个关键点：
> 越靠近开始符号的文法符号优先级越高

一个关键点：
什么是递归、左递归、右递归

> 需要注意的是，右递归在自顶向下分析中不会导致无限循环，因此通常无需消除。

### 消除二义性
消除二义性的方法：
1. 改变语法
2. 指定隐式的规则
3. 通过显式的规定优先级和结合性（即把二义性文法改为非二义性的文法）
   这个需要引入新的非终结符

关键：这个是在自上而下的分析中的情况，那么什么是自上而下？？

二义性的危害
也就是这颗树不一样到底会产生什么危害？
树的结构到底代表了什么问题？

通过自上到下分析的方法可以知道如果一个语句是有二义性的，那么这棵树是不唯一的，可能推导出一个和原义不符合的树

1. 优先级
2. 结合性

```
关于优先级和结合性的正确认识
并不是深度越低越ok。对分析树的认识又深一点

看那里先成为了一颗独立的树

都知道这个字符串的规则是从左到右，叶子节点是终结符。而真正执行的时候是

```

![[Pasted image 20250406211406.png]]
这颗树为例，右图id + 的不是 id * id ，而可以看作为 term。这个整体在给id运算之前就应该是运算结束了的。所以乘法的优先级会更高

所以消除二义性的时候
1. 每个优先级的运算符引入新的非终结符。并且规定他的结合性。相同优先级的运算符使用同一组就够了
2. 正确的式子应该是从优先级低的非终结符推到优先级高的符号
3. 结合性规定：左结合非终结符就应该在左边



## 自上而下的语法分析

原来自上而下的语法分析的方法就是一个“自上而下”的不断试错的过程。举一个例子：
![[Screenshot_20250406_205244_com.orion.notein.jpg]]
[国科老师讲自上而下语法分析](https://www.bilibili.com/video/BV1DJ411M7eV?spm_id_from=333.788.videopod.episodes&vd_source=6ca6bce6ab790fe02889f85c0ef90f8a&p=61)

所以说自上而下的分析方法是不断地试探。
也是因为这样，当程序出现左递归的时候就会出现死循环。
```
本身就是因为读到这个部分的时候无法匹配所以需要进入下一层。结果遇到的还是他。
```


![[Pasted image 20250406205859.png]]

可以看出越深越先运算

## 消除左递归

直观感受这个是一个将左递归化为了右递归的方式

两种技术分为了
1. 直接左递归方法
   加一个新状态，变成新状态右递归
2. 间接左递归方法
   间接左递归要换成直接左递归（自己不会的东西要转化为自己会的东西，找到联系就找方式转换）

人话：
单独变左侧，右侧变左侧

如果遇到多重的情况：
`S -> SSA` 
这种情况，就将`SA`看作一个`B`然后得到一个东东，最后用`S`推出来的东东将`S`替换掉。

如图：
![[Screenshot_20250406_221716_com.orion.notein.jpg]]

一些没用的东西：
- 无用符号
- 无用产生式

![[Pasted image 20250406223041.png]]
这些东西要删掉

例如：
![[Pasted image 20250406223059.png]]
## 提左因子

提左因子就是很简单的
提 左因子。

因为自上而下的语法分析其实是通过得到字符（或者说token之后进行判断，做出相应的选择）之后通过不断的重复、回溯、判断得到的结果。所以当如果遇到有一些情况，目前掌握的情况可以做出多个选择，为了后面少回溯就需要得到更多的内容，所以他会提取当前几种选择的左边的公因子让他得到更多的内容之后再做抉择，避免不必要的回溯。

如图
![[Pasted image 20250406224933.png]]

他将共同的
```
if expr then stmt 提取了出来，并且创建新状态用以实现后续的选择
```


## LL文法

LL文法是自上到下分析的一种特例，他通过使用两个特殊的函数得到的集合实现了精准的选择。使用教材的方式就是：
如果这个选择不行的话就没有选择可行了。

LL 满足这两个要求和特点：
对于任何两个产生式子：$A->\alpha|\beta$都满足下面条件
1. $FIRST(\alpha)\cap FIRST(\beta) = \emptyset$ 
2. $若\beta\rightarrow^*\varepsilon$，那么$FIRST(\alpha)\cap FALLOW(A) = \emptyset$

```
总结：
LL文法到底是个什么🪝
LL文法，表示Left-to-right Leftmost derivation(从左到右的最左推导)的文法。
LL(1) 表示解析器在做出解析决策的时候只需要向前查看1个符号就ok

之前已经提到过了，文法就是一个关于这个语言的规则体系，这个语言由他的文法而创造。文法就是一个四元组
提到文法我们应该很快想到
S -> S + S
S -> S * S
S -> id

这样的东东

LL(1)文法就是支持其两个特性的文法，由于他的特性导致他有特殊的规定
1. 使得这个A的推导具有唯一性，也就是如果我得到了一个a作为输入的话，我的选择是唯一的，如果不唯一就出现了矛盾，就无法不回溯的实现自上到下的查找
2. 同理，因为如果B能推出空集，我将不知道我使用的是a还是Ba,所以要求并集为空
```

```

前提：
因为提左因子的方式使得选择的唯一性。因为一个前缀一定是没有两个选择的，如果有就提因子。
明明定义非常的明确并且好，但是也能讲的司马一样的复杂也是司马
```


两个函数，说人话就是首先因为提左因子的方式实现
- FIRST
- FALLOW：三看
	- 一看这个非终结符的推到式开头的东西
	- 二看这个终结符所在的推到式右边的东西
	- 三看上级推导式的fallow.

如何更好更准确的得到FALLOW集合？？？


所以意识

## 构造预测分析表

```
人话：
M[A,a]
就对应A行a列
如果 A->选择1 | 空集

选择1中以
```

# 自下而上分析

两种冲突：

# 4.9
![[Pasted image 20250409133521.png]]

特点：
![[Pasted image 20250409133634.png]]

# 构造SLR分析表

概述：
![[Pasted image 20250409133955.png]]

几种分析方法：
![[Pasted image 20250409134406.png]]

![[Pasted image 20250409134439.png]]

_CFG：上下文无关文法_

分析方法依赖于文法

建项目 -> 
LR(0)项目：使用识别点

$A\rightarrow \varepsilon = A\rightarrow .$

1. 从文法构造识别活前缀的DFA
2. 构造LR(0)项目集规范族

拓广文法的意义：
1. 规范acc状态


```
一个状态：

E -> .E // 核心项目
---
E -> .E + T //非核心项目， 这里右边通常是以.开头
E -> .T
T -> .F
F -> .id
```

关键：
看核心项目。
看本质转移，如果一个东东的非核心项目和另外一个东东的规范族是一样的，那么他的转移也就是一样的

理解这里和DFA的关系

这个是一个识别活前缀的DFA 

特点：
- 有效项目：

逐渐理解为什么是自下而上

目的仍然是获得一棵树，那么

我们拿到的是什么？：一串字符串
目标是什么？：拿到一棵分析树

# 从学术和本质的角度来看语法分析

> 语法分析的目标是：根据语言的“文法结构”，判断一串“词法单元”（token）是否构成一个“合法的句子”，并构造出它的“语法结构（语法树）”。

在语法分析阶段他会实现：
1. 判断这个句子是否符合给定的文法（由于这里会有嵌套规则，所以有限自动机是无法实现的）
2. 构造语法树 / 抽象语法树。（他会用于后续阶段来判断这个句子是否符合语意）
   在构造语法树的过程中顺便就实现
	1. 识别语言层次结构
	2. 判断识别优先级、结合律等

构造他的基础就是上下文无关文法：
文法就是一个四元组，而上下文无关文法仍然是四元组。文法这种东西类似与正则，他规定了他进行文字匹配的规则。

在语法分析阶段我们也是使用这些规则实现语法树的建立。由于是创建创建语法树，所以书本上介绍了自上而下和自下而上的两种方法。但是有一种感觉，感觉到这个并没有像词法分析那么数学化，是语法分析不够专业吗？不是的，这里有一个下推自动机的概念。

下推自动机（PushDown Automation, PDA），可以形象的理解下推自动机就是有限自动机 + 一个无限栈空间

>和有限状态机能识别正则文法类似，上下文无关文法也能由一类状态机来识别。
>[引用](https://longfangsong.github.io/automata-3/)

这就是PDA。而PDA是有限的自动机，不能使用有限自动机描述上下文无关文法的一个重要原因是因为有限状态，由于有限状态机没有记忆，在处理嵌套时他如果需要处理就需要无限多的状态，但是不合理。所以使用PDA之后，无限大的栈空间使得状态机有了“记忆功能”，他知道嵌套了多少层，从而可以实现准确的匹配。

而他也是需要状态的（这也就是为什么在那个LL和LR生成的表中，总感觉有一种状态转移的感觉，因为本身这个就是一个状态机状态转移的过程）
而他的状态也就是状态机所处的状态。或者说我们可以看到在非递归预测中，表的左侧就是这个状态机的状态。

在LL文法中也许感受不是很真切，但是在LR文法中可以很直接的感受到，因为我们上来就创建了一堆状态，然后创建action 和 goto表。而其中goto表就是这个状态机状态切换的规则。

> ...goto函数，都是识别G活前缀的确定有限自动机的转换函数

规范句型是通过最右推导得到生成的中间符号串，而活前缀是规范句型的一个前缀，他不会超过这个句型的句柄的右边界。而句柄就是在一个文法中的某个产生式的右部，他是规范句型中的最左的可规约字串。

所以这个过程就是
1. 读入字符，一直读，会读到栈里，也就是s动作
2. 然后由于我们构造了相关的DFA识别活前缀，我们的分析栈中会始终都是活前缀，如果遇到了相关的句柄此时就会发生规约。
相当于通过最左规约的方式实现最右推导

> - 这里一定要搞清楚,DFA是识别活前缀的，而不是识别输入串的。识别完一个活前缀，归约成非终结符后，又会从状态0开始重新识别新的活前缀。 -- ppt内容

所以我们可以看到规约之后栈里的东西会pop出来。后面虽然再push进入了，但是从侧面印证：栈里存放的不是识别串。

那么我们就可以理解了

所以在创建LR表的过程，栈里会存放一些文法符号，这些文法符号什么时候规约呢？
遇到活前缀的时候规约，而活前缀规约的规则

突然又记起来将咽炎的 全都是状态机 的说法了，查询一下之后发现状态机这种概念深入计算机科学之中。


