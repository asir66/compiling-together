# 导言
1. 语法分析要做什么：
   将记号流 -> 语法树
   ![](Pasted%20image%2020250313103305.png)
2. 语法分析学习关键词
	- 分析树
	- 文法
		- 上下文无关文法
			- 四元组
				- 产生式和推导
			- 语言
				- 句子
				- 句型
				- 句柄
			- 二义性
				- 消除方法
	- 自上而下分析
		- LL(1)文法
			- 两个问题
				- 左递归 - 消除左递归方法
				- 回溯 - 消除回溯
					- first
					- fallow
		- 预测表算法和构造
			- 非递归的预测分析
	- 自下而上分析
		- 规约
		- 使用栈实现移进-规约分析
		- LR(k)分析算法
		- LR文法
		- 预测表使用与构造
			- SLR文法
			- LR(1)文法
			- LALR文法
	- 冲突的解决方案
	- 错误恢复

>课程提要
>本课程主要讲前端的内容。因为优化太难而代码生成器直接替换就行。

上下文无关文法例子：
```c
int a;
a = b+1;
```
在上下文无关文法看来这个语句是合理的，因为本语句是符合语法规则的。他并不由上下文影响。

语法分析器的位置
![](Pasted%20image%2020250313104330.png)
在综述中我们也提到分析器其实是主体，它调用词法分析器

# 文法和形式语言
![](Pasted%20image%2020250313104901.png)

形式语言由[乔姆斯基](https://zh.wikipedia.org/zh-hans/%E8%AF%BA%E5%A7%86%C2%B7%E4%B9%94%E5%A7%86%E6%96%AF%E5%9F%BA)提出，使用一种数学的方式定义语言。部分定义如下：
1. 语言是句子的集合
2. 句子是单词的符合规则的连接
3. 规则称为文法

乔姆斯基为了让人们通过数学框架，理性的方式研究语言，提出了形式文法的概念，并提出乔姆斯基层次，将文法分为：分析难度逐级递减
且随着人们研究的发展，这四种文法分别对应着一种自动机：
 - 0型文法：无约束文法 - 图灵机
 - 1型文法：上下文有关文法（CSG） - 线性限界自动机
 - 2型文法：上下文无关文法（CFG） - 非确定下推自动机（PDA）
 - 3型文法：正则文法（RG） - 有限自动机（FA）

并且将句子结构形式化，部分定义如下：
- 前缀、后缀、串[[词法分析#从语言到记号]]

- 句型：在文法推导过程中的每一个产生的串
  例子：A->Bc  B ->Ca ... 那么A、Bc、Cac...都是句型

- 句柄：**句柄**是在句型的推导过程中，能够直接替换为一个非终结符的部分，通常是通过文法的产生式进行替换的子字符串。
  而后人们将直接替换的过程称为规约。

- 规范：即最右，后面可以接动词和名词变成：规范句型、规范推导。人话说就是用最右的方式

# 上下文无关文法
上下文无关文法（Context-Free Grammar）是一种能力强于正则文法的文法。其对应PDA，由于有一个无限长的栈的存在使得上下文无关文法可以记录嵌套层次从而抛弃了正则文法使用状态来记录记忆的方式。实现对于嵌套的识别。

正规式和CFG区别：
- 可以：
	- 固定的模式
- 不可以
	- 匹配
	- 嵌套
	- 自嵌套

而上下文无关文法允许自嵌套。从而正规语言是上下文无关语言的子集
## 定义
![](Pasted%20image%2020250313110451.png)
## 推导
推导：
将人话就是从产生式得到一个语言实例

一些概念和记号
- 递归：$A=>^*xxAxx$
	- 直接递归$A->^*xxAxx$
- 位置递归
	- 左递归$A=>^*Axx$
	- 右递归$A=>^xx*A$
- 递归文法![[Pasted image 20250428124846.png]]

优先推导位置（遇到非终结符先推导谁的问题）：
- 最左推导
- 最右推导（规范推导）：最右 <-> 规范
	- 规范句型
		- 活前缀 - 规范句型 - 句型
		- 句柄

逆推导：-> 规约，一个终结符串导非递归符

## 分析树（Parse Tree）
分析树是一个概念上的东西
> 有些语法分析器并不会显式地构造完整的分析树，而只是验证输入是否符合文法。例如，**LL(1) 解析器** 和 **LR(1) 解析器** 在某些情况下只进行语法分析，而不生成分析树，分析的过程就是通过状态机的状态变化来判断是否符合语法规则，而不涉及到树的生成。对于某些优化过的编译器或解析器，这种分析树可能只是一个内部的概念或结构，而不会被显式地生成。
> 
> 所以其实我们这里的语法分析只是做语法合规判断而已

一个例子：
![[Pasted image 20250428125721.png]]

而同一个文法，同一个句子即使是相同的推导方式（最左或者最右）也生成不一样的语法树。则我们称这个文法具有二义性
### 二义性
例子：
![[Pasted image 20250428130026.png]]

不同的语法树结构会导致这个语法执行结构的区别，简言之带来了：
- 优先级
- 结合性

举个🌰：优先级
上图左图中`id*id+id`其实是`id*(id+id)`。因为和`id*`的对象是`E`，是一个整体。所以这句话中`+`的优先级大于`*`

举一个🌰：结合性
```c
        +
       / \
     id   +
          / \
        id   id
```
这里`+`就是一个右结合的文法符号

==基本上CFG都会要求无二义性，后续不再提。但是冲突恢复方案的时候可以使用隐形规则解决，后续提==

### 消除二义性
消除二义性的方法：
1. 改变语法：例如，`id*id+id => (id*id)+id`
2. 指定隐式的规则，即后续中使用的错误解决方法中提到的
3. 改变文法，改为非二义文法
   这个需要==引入新的非终结符==
这些工作的本质其实都是在解决优先级和结合性。这也是本章最后冲突解决的思路
主要讲第三个方法：

本质解决
1. 优先级
2. 结合性
![[Pasted image 20250428135903.png]]

消除二义性：
1. 确定符号优先级，和结合性
2. 为每一层优先级符号设置一个非终结符。产生式的正确规则应该是优先级低的推出优先级高的运算符。
3. 结合性：A->A+a就是左结合，A->a+A就是右结合
4. 特殊情况特殊讨论

举个例子：
```c
S->S and S | S or S | not S | true | false | (S)
得到
O->O or A | A
A->A and N | N
N->not N | (O) | true | false

分析过程：
首先确定优先级： not > and > or
所以创建三个非终结符代表他们 N A O
然后确定推导关系：低优先级推高优先级
确定结合性
```


# 自上而下的语法分析

自上而下的语法分析是一个不断试错然后回溯的过程。效率低，不易自动化
举一个例子：这是一个大致的过程而不是后续具体的算法
在后续的算法中加以first集和fallow集可以使得他不需要回溯。
![[Screenshot_20250406_205244_com.orion.notein.jpg]]
[国科老师讲自上而下语法分析](https://www.bilibili.com/video/BV1DJ411M7eV?spm_id_from=333.788.videopod.episodes&vd_source=6ca6bce6ab790fe02889f85c0ef90f8a&p=61)

所以要提高自上而下分析的文法的效率需要做两个操作：
- 消除左递归（必须，因为左递归会使得自上而下分析无法进行）
- 提左因子（提高效率，可以减少）

消除左递归原因：
当程序出现左递归的时候就会出现死循环。
```
人话：
自上而下语法分析的过程是从S开始，然后读终结符，然后从非终结符开始找选择，看有没有能吃掉这个终结符的选择。

但是如果这是一个左递归的文法，那么就会一直陷入左递归中，吃不到符号从而无法进入下一步
```
## 消除左递归
直观感受这个是一个将左递归化为了右递归的方式

总结：
两种技术
1. 直接左递归方法
   加一个新状态，其他选择左移加新状态，新状态变新状态右递归，引入空串
	```c
	A->Aa|B
	可以化为：
	A->BA'
	A'->aA' | 空串
	```
3. 间接左递归方法
   间接左递归要换成直接左递归（自己不会的东西要转化为自己会的东西，找到联系就找方式转换）

举一个🌰：
![[Pasted image 20250428152106.png]]

![[Pasted image 20250428153352.png]]

如果遇到多重的情况：
`S -> SSA` 
这种情况，就将`SA`看作一个`B`然后得到一个东东，最后用`S`推出来的东东将`S`替换掉。

一些没用的东西：
- 无用符号
- 无用产生式
![[Pasted image 20250406223041.png]]
这些东西要删掉

例如：
![[Pasted image 20250406223059.png]]
## 提左因子

提左因子就是很简单的
提 左因子。

> 提左因子的意义：减少回溯
> 减少选择，减少回溯

如图
![[Pasted image 20250428153545.png]]

他将共同的
```
if expr then stmt 提取了出来
创建新状态表示后面的不同的选择
```
## LL文法
（Left-to-right Leftmost derivation）即，从左到右（扫描输入），最左推导。的文法

LL文法是自上到下分析的一种特例，他通过使用两个特殊的函数得到的集合实现了==精准的选择==。使用教材的话就是：
如果这个选择不行的话就没有选择可行了。

LL 满足这两个要求和特点：
对于任何两个产生式子：$A->\alpha|\beta$都满足下面条件
1. $FIRST(\alpha)\cap FIRST(\beta) = \emptyset$ 
2. $若\beta\rightarrow^*\varepsilon$，那么$FIRST(\alpha)\cap FALLOW(A) = \emptyset$
人话：对于任意的产生式：A->
对A推出的串的第一个字符对应的选择一定是唯一的

考点：如何判断一个文法是不是LL文法？
看定义，找冲突

```
总结：
LL文法到底是个什么🪝
LL文法，表示Left-to-right Leftmost derivation(从左到右的最左推导)的文法。
LL(1) 表示解析器在做出解析决策的时候只需要向前查看1个符号就ok

LL(1)文法就是支持其两个特性的文法，由于他的特性导致他有特殊的规定
1. 使得这个A的推导具有唯一性，也就是如果我得到了一个a作为输入的话，我的选择是唯一的，如果不唯一就出现了矛盾，就无法不回溯的实现自上到下的查找
2. 同理，因为如果B能推出空集，我将不知道我使用的是a还是Ba,所以要求并集为空
```

```
前提：
因为提左因子的方式使得选择的唯一性。因为一个前缀一定是没有两个选择的，如果有就提因子。
明明定义非常的明确并且好，但是也能讲的司马一样的复杂也是司马
```

两个函数（集合）定义：
- FIRST
- FALLOW

### 如何求FIRST和FALLOW集合
- first，先看左，从下往上算
	- A->axx，则a属于
	- A->Bxx，则first(B)属于
	- 若出现空串，则后面补上，当且仅当$A->^*空$的时候，{空}才能包含到first(A)
- fallow，看右边，从上往下算，开始符号天然带$
	- xx->xxBd，则d属于
	- A->xxB，则fallow(A)属于fallow(B)
	- A->xxBD，则first(D)除了空都属于fallow，如果有空则后面补上，如果没有后面则A补上。
总结：
明确定义，遇到空后面补上

### 基于LL文法的语法分析实现
有了LL(1)分析文法之后，其实我们就有成熟的方法实现语法分析了：
- 递归的（实际编写文法分析器的时候我们可能就会这样写）
- 非递归的（我们手动实现，考试用，理解PDA）

#### 递归下降的预测分析
递归下降的预测分析就是直接写LL文法。因为LL文法是我们需要设计的。我们在设计之初就已经设置的不需要回溯了，也就不需要一步步的尝试。（因为如果这个选择匹配了之后后面发生了错误一定是输入错了，因为往上回溯是没必要的，因为没有同一个FIRST）

所以直接写下我们的LL文法（这个在语法制导翻译那里应该也是这样设计的）
#### 非递归的预测分析
非递归的预测分析需要我们显式的实现一个栈。所以我们需要以下三个东西：
1. 栈
2. 分析表
3. 输入

![[Pasted image 20250428161021.png]]
规则：
1. 栈顶的非终结符表示当前的状态，遇到输入的字符需要执行相应的动作
2. 非终结符变成非终结符，就需要栈顶非终结符出栈，对应非终结符入栈
   比如：E->TE' 表示E出栈、TE'入栈，并且由于是栈，所以呈现的最后效果是：XXXE'T
3. 栈顶是终结符，遇上一样的终结符就表示匹配上了，两者消掉
   XXXid 遇上 id+++ 则，两边id消掉。得到XXX 遇上 +++。

书p59页有一个例子，可以学习。

> 数学化的理解：PDA
> 这个表就是一个状态机器的状态转换表，栈顶元素就表示状态机当前的状态。遇到相应的终结符就需要执行相应的规则实现状态转移。

## 构造预测分析表 
![[Pasted image 20250428161700.png]]

1. 写框架
	1. 非终结符作为左侧列
	2. 终结符（$作为结束符也是）作为右侧行
2. 对于A-a这样的一个选择，分析$FIRST(a)$，把A->a放入每一个对应的终结符的条目中![[Pasted image 20250531224012.png]]
3. 如果空串在里面，就要对应A的$FALLOW(A)$的每个终结符（包括$），把A->a放进入（因为这表示a可能是一个空，则这时候这个东东可能是A后面的东西推出来的，而这时候是可以选择A->a的）![[Pasted image 20250531224306.png]]
4. 其他为error

### 预测分析的错误恢复
#代办
错误恢复等会做
![[Pasted image 20250428162514.png]]

![[Pasted image 20250428162551.png]]

特点：


![[Pasted image 20250409134406.png]]

![[Pasted image 20250409134439.png]]

# 从学术和本质的角度来看语法分析

> 语法分析的目标是：根据语言的“文法结构”，判断一串“词法单元”（token）是否构成一个“合法的句子”，并构造出它的“语法结构（语法树）”。

在语法分析阶段他会实现：
1. 判断这个句子是否符合给定的文法（由于这里会有嵌套规则，所以有限自动机是无法实现的）
2. 构造语法树 / 抽象语法树。（他会用于后续阶段来判断这个句子是否符合语意）
   在构造语法树的过程中顺便就实现
	1. 识别语言层次结构
	2. 判断识别优先级、结合律等

构造他的基础就是上下文无关文法：
文法就是一个四元组，而上下文无关文法仍然是四元组。文法这种东西类似与正则，他规定了他进行文字匹配的规则。

在语法分析阶段我们也是使用这些规则实现语法树的建立。由于是创建创建语法树，所以书本上介绍了自上而下和自下而上的两种方法。但是有一种感觉，感觉到这个并没有像词法分析那么数学化，是语法分析不够专业吗？不是的，这里有一个下推自动机的概念。

下推自动机（PushDown Automation, PDA），可以形象的理解下推自动机就是有限自动机 + 一个无限栈空间

>和有限状态机能识别正则文法类似，上下文无关文法也能由一类状态机来识别。
>[引用](https://longfangsong.github.io/automata-3/)

这就是PDA。而PDA是有限的自动机，不能使用有限自动机描述上下文无关文法的一个重要原因是因为有限状态，由于有限状态机没有记忆，在处理嵌套时他如果需要处理就需要无限多的状态，但是不合理。所以使用PDA之后，无限大的栈空间使得状态机有了“记忆功能”，他知道嵌套了多少层，从而可以实现准确的匹配。

而他也是需要状态的（这也就是为什么在那个LL和LR生成的表中，总感觉有一种状态转移的感觉，因为本身这个就是一个状态机状态转移的过程）
而他的状态也就是状态机所处的状态。或者说我们可以看到在非递归预测中，表的左侧就是这个状态机的状态。

在LL文法中也许感受不是很真切，但是在LR文法中可以很直接的感受到，因为我们上来就创建了一堆状态，然后创建action 和 goto表。而其中goto表就是这个状态机状态切换的规则。

> ...goto函数，都是识别G活前缀的确定有限自动机的转换函数

规范句型是通过最右推导得到生成的中间符号串，而活前缀是规范句型的一个前缀，他不会超过这个句型的句柄的右边界。而句柄就是在一个文法中的某个产生式的右部，他是规范句型中的最左的可规约字串。

所以这个过程就是
1. 读入字符，一直读，会读到栈里，也就是s动作
2. 然后由于我们构造了相关的DFA识别活前缀，我们的分析栈中会始终都是活前缀，如果遇到了相关的句柄此时就会发生规约。
相当于通过最左规约的方式实现最右推导

> - 这里一定要搞清楚,DFA是识别活前缀的，而不是识别输入串的。识别完一个活前缀，归约成非终结符后，又会从状态0开始重新识别新的活前缀。 -- ppt内容

所以我们可以看到规约之后栈里的东西会pop出来。后面虽然再push进入了，但是从侧面印证：栈里存放的不是识别串。

那么我们就可以理解了

所以在创建LR表的过程，栈里会存放一些文法符号，这些文法符号什么时候规约呢？
遇到活前缀的时候规约，而活前缀规约的规则

突然又记起来将咽炎的 全都是状态机 的说法了，查询一下之后发现状态机这种概念深入计算机科学之中。

# 自下而上的语法分析
综述：
自下而上的语法分析过程其实是将这棵树从下向上创建。所以这个过程会有一个下面节点合成上面节点的过程。称为==规约==

那么这部分我们要知道：
1. 我们得到一个串之后要如何处理每一个字符（移进还是规约）：对串的动作
2. 我们应该如何操作：用栈实现移进-规约操作
3. 什么时候做相应的操作：构建LR分析表的三种技术

## 一些概念
- 规约：
  人话就是推导的逆过程：
  `A->ab`则`ab`规约可以得到`A`
- 句柄
  简单理解就是最左的可规约子串。
  `A->ab`，而对于一个规范句型`abcxxx`这个句柄就是`ab`。

一句话
> **规范句型**是通过最右推导得到的中间符号串，而**活前缀**是规范句型的一个前缀，他不会超过这个句型的句柄的右边界。而**句柄**就是在一个文法中的某个产生式的右部，他是规范句型中的最左边的可规约子串。

所以最右推导为规范推导，最左规约就是规范规约。最左规约的过程就是最右推导的过程

特点：
![[Pasted image 20250415212612.png]]
这里的右句型就是规范句型的别称
## 用栈实现移进规约 - LR算法
LR算法就是使用栈实现移进规约操作的过程。其有如下动作
- 移进
- 规约
- 接受：到`$`的时候宣告分析成功
- 报错：发现错误，调用错误恢复例程

通过栈实现移进规约操作
如图：
![[Pasted image 20250415205822.png]]

这个过程我们需要知道哪个过程使用什么操作，所以我们需要一个自动机，实现状态的转移。就是后面的LR分析表。

_在上面操作过程可能会产生两种错误，后面细讲_

由于上面这个过程并没有使用到相应的表，只是我们的人脑操作，而不是一个计算机可行的算法，所以正规的LR分析算法如下：
![[Pasted image 20250415212952.png]]

人话
1. 三个栏：栈，输入串剩余，动作
2. 初始化栈（0表示初始状态）
3. 执行栈顶状态遇到相应输入的动作。解释两种动作：
	1. sX：shift（转变），即移进这个符号，并转变到相应的数字状态（数字表状态）
	2. rX：reduce（减少），即按照相应序号的生成式规则（数字表生成式序号），pop栈，并规约得到的非终结符push入栈
	3. acc：accept，表示分析成功，放在1状态遇`$`时。

[一个讲人话的教程](https://www.bilibili.com/video/BV12u411S7Us/?spm_id_from=333.337.search-card.all.click&vd_source=6ca6bce6ab790fe02889f85c0ef90f8a)

后面我们会说SLR文法、LR(1)文法、LALR文法，这些步骤其实和文法没有什么关系，我们主要是构建哪个表。而能构造那样不产生冲突的表的文法我们就说他符合规则，属于xx文法而已。
## SLR文法构造
SLR构造过程：
1. 识别DFA
	1. 拓广文法
		1. 加S'
		2. 拆开多个选择
		3. 文法加序号
	2. 构造LR(0)项目集规范族（类空闭包）
	3. 画出DFA
3. 构造SLR分析表
	3. 填action-goto表，移进和规约（规约看follow集合）

### SLR产生冲突
如果产生了冲突这个文法就不是SLR文法
冲突类型：
- 移进-规约
- 规约-规约

问题1，产生冲突的原理到底是什么？核心点在哪里？
后继符和规约
## LR(1)分析
核心提要
和SLR基本一样，只是使用==搜索符==替换FOLLOW集合使用。
而搜索符其实是FOLLOW的子集。

项目：LR(1)项目
定义：
- 在 LR(1) 分析中，我们将项目重新定义为包含**搜索符的形式：
  `[A → α · β, a]`
- LR(1) 中的 `1` 表示搜索符的长度为 1，即我们只考虑一个终结符作为前瞻符号。
- 搜索符是FOLLOW的子集，且通常是真子集

如何构造？
1. ==初始状态搜索符自然存在为`$`==
2. 生成的新项目和其原项目有相同的搜索符（==核心项目继承==）
3. 非核心项目搜索符
   非核心项目组的搜索符为这个非终结符后面的那一坨。简记为`FIRST(βa)`

3点的具体讲解：
![[Pasted image 20250416143740.png]]

一个栗子：
![[Pasted image 20250416144043.png]]

而后规约的时候需要根据对应的搜索符处填上对应的规约操作，依次可以解决两种冲突。

即：原本的操作：
- 原本的操作：如果一个东东处产生规约了，则通过查看其FOLLOW，往每个`(0-a)`处填上规约
- LR操作：如果一个状态处产生了规约。则通过查看其搜索符，在对应的位置上填上规约。

注意：
- 不要遗漏搜索符

一些性质：
![[Pasted image 20250416145542.png]]

结合例题再次理解：
![[Pasted image 20250416150659.png]]

路过了`I2`和没有路过是有区别的，其区分了这个E是在前面还是在后面。

### LR(1)的问题
状态数庞大，构造难度大。

解决方法：
LALR方法，合并搜索符减少状态数和构造难度。

一个人眼发现过程：
![[Pasted image 20250423135622.png]]

其实这里老师讲的有点模糊，关于栈内状态的一个问题：
这个状态机的状态应该是栈顶的状态标志，所以也就是为什么出栈要出两个（其实按理来说是一个，因为并不需要字符，只需要状态）那么这时候就会类似于一个状态的回退的效果

## LALR

那么如何创作这样的表：
- ==合并同心集==

> 合并同心集不会引入新的移进-归约冲突
![[Pasted image 20250423140646.png]]

将人话，如果W1和W2的并集是没有a的，那么新来的字符串是a的时候，此时就明确的知道要干嘛

- 但是会引入新的归约-规约冲突
![[Pasted image 20250423140955.png]]

所以LALR(1)构造步骤：
![[Pasted image 20250423141239.png]]

ok,那么什么叫做同心的项目集？
简单来说就是两个项目除了搜索符都是一样的，那么他就是同心的项目集

# 冲突的解决方案
解决二义性：
为什么需要这样搞呢？
解决二义性的方式我们之前已经解释了，要么加状态，要么加规定。而此前在讨论了无论是自上而下还是自下而上的文法分析方法都是需要非二义性的文法才可以分析，核心原因是

二义性文法会导致不可避免的冲突（因为本身由这个文法生成的合理的语法树就不止一颗）
但是通过二义文法可以减少状态数。所以做出一下的规定手动解决生成表的冲突：
[[语法分析#消除二义性]]

# 错误恢复
LR分析器在什么情况下发现错误？
![[Pasted image 20250423150417.png]]
![[Pasted image 20250423150847.png]]

一段人话：
![[Pasted image 20250423151303.png]]

总之找到路就行
退栈和抛弃是对两个部分，退栈就是pop栈内内容。而抛弃是抛弃输入串

解读：
1. A在这里并不重要重要的是将当前所在的这个状态出栈



## 随便一写

我们目前学习使用的编译原理的知识是一个语言学和计算机科学交叉融合的产物。