>导言：
>词法分析章节对应词法分析器。此处学习词法分析器的功能和设计方法。
>功能：将字符流转化为标识流
>所以其实这里的功能很简单，就是词法分析器要能判断这个字符串是不是正确的，我应该接收的。人家给定标准，我能够将符合标准的交给下一个。不符合的就不收

![[Pasted image 20250227105103.png]]
# 几个概念
本章设计的几个概念如下：
- 词法分析器
- 模式
- 记号
- 语言
	- 单词
- 状态转换图

>直接编写词法分析器并非一定要基于转换图概念，但是这样是为了具象化标识有限自动机的概念

功能：
![[Pasted image 20250227105623.png]]
# 从语言到记号
此处的语言即英文代表的语言。
首先该类语言需要有一个字母表。这个字母表后续语言的诞生都由字母表产生。它是集合的值域。

串：字母表符号的一个有穷序列
当我们将字母表任意排列就得到一系列的串
![[Pasted image 20250311095920.png]]
![[Pasted image 20250311095938.png]]

串的运算：
- 连接
- 积（指数、幂）

语言：符号的有限集合 —> 所以语言 = 集合
自我感觉这个定义是十分合理的，因为当所有的符合条件的词组合在一起就构成了这个语言的基础，而规则就是语言的定义
- 他其中的单个元素即称为字或单词

作为集合他就有集合的运算
- 交、并、补、差
- 连接、指数、闭包--引：正闭包

而语言下有很多
- 句型：句型应该放在语法分析，详细讲来就是一个语言从开始符号推导出来的东西。完全推导到全是终结符就是句子，他们全都是句型

## 记号
词法记号是一个二元组。这个二元组的作用就是保留单词信息的同时，提供该单词的附加信息。并交予后续部件
![[Pasted image 20250227110840.png]]

词法记号（记号，token）：(token, 属性值) - (记号名, 属性值)
其中记号名是一些规定的，又分类的记号。在后续的语法分析中他可以告知语法分析器这个单词是个什么东西。

> 举一个例子
> if (sum > 0) retunr 1sum; 这个句子
> 词法分析器得到之后将会
> 1. 简而言之，if 在DFA中就会进行状态转移并在读到` `时结束，并进入if关键字的接收状态。其他类似。而1sum由于没有相应的规则接会进入死状态
>    
> 2. 传给语法分析器。
>    识别到token，就传给语法分析器
>     
sum这种就是标识符，标识符由于多种多样性并不能一词一类。要多词一类。并存在表中

所以得到
![[Pasted image 20250311102503.png]]
## 正规式（[[正则表达式]]）
简而言之，正规式就是正则表达式。他通过一系列的规定，实现了对形式化表述到一种规范标准的表述间的转换。
1. 定限制
2. 看长度

注意正则表达式的优先级：
![](Pasted%20image%2020250311155124.png)
闭包 > 连接 > 或，所以看到或直接分两边
# 如何得到一个词法分析器
## 状态转换图
状态转换图是有限自动机的一种可视化描述。这里为了更好的描述有限自动机以及构造过程中的实现，首先学习状态转换图。

状态转换图由：
- 节点构成状态
- 有向边指向下一个状态
- 开始箭头指向开始状态，双圈表示接受状态。接受状态不唯一，表示该模式能够接受的字符流

如图：
![[Pasted image 20250311145734.png]]

## 有限自动机
什么是有限自动机？有限是什么意思？自动是如何自动？
> 有限自动机是用来描述一个系统在不同状态之间根据输入进行转移的过程。有限描述的是这个状态和输入是有限的。这和正则式相符合。自动表示这个系统会根据输入自动的变换状态。

又分为
- 不确定的有限自动机（NFA）
- 确定的有限自动机（DFA）

NFA定义：
![[Pasted image 20250305134605.png]]

DFA定义：
![](Pasted%20image%2020250311151717.png)
人话：
从有限的状态转换出去。
- NFA可以有空边和重边
  这导致NFA在有的状态接受到字符的时候状态走向是不可确定的。他的图会更简单。但是由于错了要回溯导致他的运行速度会下降。
- DFA不能有空边，不能有重边（可以写作部分函数，也可以加死状态让他变成全函数）
  所以DFA状态数会增多，而DFA遇到了字符输入有唯一的出口，这使得他的状态变化是唯一确定的，但是由于确定性其运行速度会快很多。

### 有限自动机的一些概念
---
==部分函数==解释：
部分函数表示一部分定义域没有定义的函数。比如说`/aabb/`这个正则表达式子。他的DFA就应该是：
![](Pasted%20image%2020250311153209.png)
可以看到，全函数应该是每一个状态都会收到a,b边而后进入下一个状态。但是这里其实是不需要的。
但是后续为了做表时完整我们可以通过死状态使其构成全函数
> 同时这个操作也是极好的，也就是我们可以认为DFA中图是全函数

---
但是可视图并不适合计算机理解，所以可以转化为矩阵：
==状态-符号矩阵==
![[Pasted image 20250305140320.png]]

---
==最长字串匹配原则==：
![](Pasted%20image%2020250311155622.png)

---
==死状态==：
死状态也称为陷阱状态（Trap state）。一旦进入这个状态之后无论输入什么都只能停留在这个状态上。所以这个输入一定会被拒绝。
所以我们常常用他来使得每个输入都会经过分析器，但是不符合规定的字符串不会接受

在DFA中创建而在NFA中没有必要创建。因为NFA是要回溯的
所以在DFA做状态转换表的时候我们会发现有一个地方会走向空。那么此时我们就应该设计一个死状态让他进入。并实现死状态自达
![](Pasted%20image%2020250311163046.png)

## 从正规式子到词法分析器
这幅图是核心
![](Pasted%20image%2020250311163132.png)

### 从正规式->NFA：Thompson算法
由Ken Thompson设计的算法
![](Pasted%20image%2020250311162533.png)

定义：
![[Pasted image 20250305143519.png]]

简单理解Thompson算法：
核心就是简单的组合，我们将正规式的基本操作单独作图而使用状态重叠连接起来。由于简单所以并不会出错。借助空操作增加状态使得不会出错

**或操作**：
![[Pasted image 20250305143708.png]]

**连接操作**：
![[Pasted image 20250305143807.png]]

**闭包操作**：
![](Pasted%20image%2020250311163159.png)

#### 留白-考试技巧篇

或：
- 或操作的关键是分支。如果是单一操作的话可以将操作直接置于分支上。减少空操作。置于前分支还是后分支关键看分支后有无继续分支的操作。建议均置于后分支。

闭包
- 单一操作的闭包就是自环，而其他操作的闭包不能直接自环
  如果是系列操作，可以通过加上空环和下空环的方式

### NFA->DFA：子集构造法
转换理论基础：
- DFA和NFA的等价性：
  即对于任意DFA一定存在NFA与其等价，反之亦然。

解决思路入下：
- ==DFA的一个状态是NFA的一个 状态集合。==，同时这就是子集的概念：部分集合

>简言之，这里相当于是利用了一些状态等价性。因为状态 a -> b是1转换的，b -> c是空转换的时候，其实到a到b = 到c。

运算定义：
![[Pasted image 20250305151907.png]]

> 所以s的空闭包也就是s的等价状态，T的空闭包也就是和T中元素等价的状态集合
> move 实现通过固定线路能转移到的状态，真的要移动，所以一般不会有自身
> 
> 但是空包是可以不移动的，所以空包会包含自身

所以举一个例子：
![[Pasted image 20250306104110.png]]
所以（$\varepsilon -closure$简称空集闭包，简称空闭）
1. 创建开始状态，开始状态就是 开始状态0的$\varepsilon -closure$。
2. 而后开始递推，以开始状态A为起点，然后计算 空闭 ( move(T,a) ) -> B。直到没有新状态。
3. 如果状态去不了地方可以创建死状态给他走，最后死状态只能回到自己

这里规范的做法，在算一个状态的时候应该写作：
![[Pasted image 20250412110129.png]]

==也就是是谁的空包，这个很重要，避免重复情况要逐一匹配的情况，我们只需要看是谁的空包就行了。==

### 化简DFA：等价划分法
> 理论上，不计同构，每一个正规集存在唯一最简DFA

前提：
1. 该方法适用于全函数，如果不是全函数需要创建死状态使得函数成为全函数
	1. 如何看有没有：这个符号表定义域是a, b。有一个点只有a出没有b出，那么就不是全函数。需要创建一个b出到死状态。
2. 简单理解：找等价状态，合并等价状态

如何定义DFA的等价状态：
我觉得DFA的等价定义很流氓：
![[Pasted image 20250306115143.png]]

> 找等价状态是困难的，所以找不等价状态。直至没有不等价状态。剩下的都等价

所以：
1. 找区别
2. 划分
3. 重复

解释：
不等价状态需要状态到达情况的区别。所以首先将接受状态与非接受状态划分。
在通过划分情况重复划分。找到可区别性就行。当

一个例子：
![](Pasted%20image%2020250311171628.png)
-->
![](d1d011a0cd37a3fb0eaf2014f71fee11.jpg)

在每次我们选择一个就行，但是最后如果通过a发现不可划分，不代表通过b不可划分。
> 我们需要找的是等价状态，通过逆向转化为找非等价状态。直到找不到不等价状态
> 这个等价状态是通过状态转移划分的。所以只要这个状态通过相同的路径走向不同的状态，那么他就是非等价状态
> 
> 而最开始的区分需要一个基本划分，就是接收状态和非接收状态

### 最简DFA->识别器
到这里其实已经很简单了。接下来要做的就是：查表。


## 作业经验：
不能跟的时候就在中间加其他东西就可以
a不能跟b。
就在ab中间加其他东西。