语法制导翻译（Syntax-Directed Translation），直译也就是语法指导下的翻译。书上的解释如下：
> 大家看到了一种有用的**描述形式**：==将语法构造的属性附加在代表语法构造的文法符号上，这些属性值由伴随着文法产生式的语义动作来计算，而语义动作的计算是在对应产生式被规约时进行，由此得到结果==。这种**描述形式**可用来描述编译器的语义分析和中间代码生成等，因此本章系统地研究这种被称为“**语法制导的语言翻译**”的描述方法以及实现。

所以说白了这是一种方法，通过设计**属性**和**语义规则（语义动作）** 实现翻译（也就是属性的计算，或者是语义动作的执行）

所以本章
1. 明确定义-是什么 -> SDD
2. 明确属性
	1. 综合属性
	2. 继承属性
3. xxx再说
# 语法制导定义

> 语法制导的定义是带属性和语义规则的上下文无关文法
> 说白了，SDD给了一个用于语法制导翻译的规范。他的语义规则是形式化的，告诉我们这个意思就好了，计算机不可执行

我自身认为这个定义非常好，并且理解SDT的含义就可以很容易的理解这个定义，需要语法分析（上下文无关文法）、属性、语义规则

定义的形式：
![[Pasted image 20250507135948.png]]

写作：
左边产生式、右边语义规则（语义规则中带属性）

> 在教材110页有一个数学化的定义，但是过于抽象并且并没有对理解有多大帮助。所以不做记录

其中他语义规则中属性可分为：
1. 综合属性（**synthesized attribute**）
2. 继承属性（**inherited attribute**）
3. 虚拟属性（**virtual attribute**）：小小解释，虚拟属性与综合与继承是不冲突的，也就是说可以有虚拟综合属性

在语义规则中往往会定义一个或多个表达式，这样可以通过表达式计算得到产生式左侧非终结符的某个属性值，完成翻译。（==所以我们写SDD语义规则的时候按照给的要求写表达式就好了==）

而有的规则是：输出属性值或者其他与当前这个属性值没关系的动作，这样的影响我们称之为“**副作用**”。但是为了让每一个动作都能对应着一个属性（这样在后面写翻译行为的时候就可以统一），我们就会使用虚拟属性。
> 一个例子：上面式子中的第一个L->E.n == print(E.val)写属性依赖图的时候，L需要一个虚拟属性$i$，并且i依赖于$E.val$

> 定义：没有副作用的语义制导定义->属性文法
## 两个属性
接下来分别拆解SDD中的各个定义

- 综合属性：
  该属性由他的子节点或他本身的属性值来计算
- 继承属性：
  该属性由他的兄弟节点、父节点、或他本身的属性值来计算

## 属性依赖图
我们的核心问题其实是计算属性（也就是翻译问题），由于两种属性间依赖的对象不一样，导致计算方向不一样，属性依赖图是想告诉我们计算的时候应该如何计算
> 这适用于手动操作，没有规定，所以不好自动化

属性依赖图定义：
![[Pasted image 20250507144634.png]]

说人话，$L \rightarrow L_1 L_1.in = L.in$，也就表示in这个属性是一个继承属性，其依赖于其父节点的$in$属性。所以箭头指向为：被依赖的属性指向依赖

![[Pasted image 20250507145054.png]]
那么通过重复这个过程，并且补充虚拟属性，我们就能得到一个属性依赖图。
这个图很关键，因为通过这个图了解到了依赖关系就可以明确先算谁在算谁，就得到了一个属性计算顺序。也就能完成翻译。

而这个过程依照的规则我们在数据结构中就已经学过了：拓扑排序
## 拓扑排序
简单来说就是先把没有入度的点去除，逐一去除直到没有就实现了这个排序的过程。

那么这样的好处在于我们当前计算的属性的依赖一定是已经得到了的了。
通过这样的方法我们可以实现手动语法执导翻译。

但是这样是不够优雅的，因为计算机一个守则就是重复的，规则的工作就应该让计算机实现。但是受限于计算顺序不好确定的原因，并不适合编写程序实现。于是我们规定了两种特殊的语法制导方案，明确属性计算顺序就能得到自动化解决方案。

> 注：为了即使是手工我们也设计一个简单的规则：从下到上，从左到右

# S-SDD和L-SDD
所以我们规定了
- S-SDD（S属性的语法制导定义，简称为S属性定义）
  即仅仅使用综合属性的语法制导定义，S表示综合属性（**synthesized attribute**）
- L-SDD（L属性的语法制导定义，简称为L属性定义）
  即属性信息从左到右的语法制导定义，L表示属性信息从左到右流动（Left to right）

> 书上的定义高度简单易懂：总结也就是不依赖右项，我们就称之为L-SDD
> ![[Pasted image 20250529112135.png]]

而因为S-SDD（从下到上）和L-SDD（从上到下）有方向性，所以我们规定之后可以在LR语法分析和LL语法分析的时候顺便实现他。完成语法制导

> 在教材117描述了这两种SDD如何跟随LR、LL语法分析进行语义分析
## 语法树
语法树即抽象语法树（Abstruct Syntax Tree， AST）。是语法分析树（Parse Tree）[[语法分析#分析树（Parse Tree）]]的浓缩表示。需要加以区分：

AST的关键区别在于：
1. 算符和关键字不再是作为叶结点，而是作为分支结点。
2. 单非产生式链（单个非终结符产生式链）可能消失
![[Pasted image 20250529113600.png]]
![[Pasted image 20250529113809.png]]
并且需要对使用何种数据结构进行存储进行学习。
## 翻译方案
翻译方案：
> 语法制导的翻译方案（SDT）和语法制导定义（SDD）不同之处是他的语义动作（注意区分语义规则）放在 { } 内 ，并且可以插入到产生式右部的任何地方。这是一个动作和分析交错的表示法，以表达动作的执行时机。
>
> 若$A \to \alpha \{...\} \beta$
> 那么中间的$\{...\}$就是在$\alpha$规约（推导）之后，$\beta$规约（推导）之前

一个例子：
![[Pasted image 20250514134825.png]]
其中语义动作是具体的动作，也就是具体的代码。

### 具体应该如何翻译呢？
![[Pasted image 20250531211057.png]]

所以，总结：
1. 翻译的时候写的就是语义动作而不是语义规定，所以是可执行的语句而不是抽象的规则。剩下的区别就是位置
2. 综合属性位置没有什么区别，放在最末尾就行
3. A的继承属性放在紧靠在A的前面，比如下面的L.in，紧靠在L的前面。

![[Pasted image 20250531211255.png]]

> 解释：
> 所以如上所说，L有继承属性，而如果要规约这个L就需要这个继承属性，那么继承属性需要先于文法符号产生。所以我们就可以知道语义动作需要出现在文法符号之前。
> 而综合属性是并不依靠父节点和兄弟节点的。所以他们的语义动作直接放在末尾就好了。

## 翻译方案这样设置的原因

回顾语法制导翻译的时机：书上的说法是
> 若A->a { ... } b的话，则 { ... } 发生在 在a推导（或向a的规约）结束之后，在b推导（或向b的规约）开始之前。
> 这样是保证b的这个继承属性在计算之前，涉及到他前面的那些需要的属性都被计算出来了。（由定义，这里是不会有环的，放心）
> 那这里有一个疑问？如果是规约的话，如果是他需要计算A的一个属性值，我是如何保证这个属性值被计算出来了？？？
> 答案是，如果我们针对这个L-SDT使用的是LL文法，自上而下分析，也就是分析预测法实现的话A一定已经被计算出来了。
> 如果不是的话，即使用的是LR文法，像gcc一样是LALR的话，其实编译器内部会使用全局变量啊，栈特性啊等方式（龙书5.4.4也有介绍用综合属性替代继承属性）
# 考试

如何考：
给一个表达式，写出表达式后缀表示。
给一个回文串，得到在哪个位置回文的

L属性的自上而下计算时转换为翻译方案的规则
![[Pasted image 20250514145831.png]]
据说一定考
翻译的过程中插入的位置很重要。